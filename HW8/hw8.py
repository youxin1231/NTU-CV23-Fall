import cv2
import numpy as np
import math

def gaussian_noise(img, amplitude):
    height, width = img.shape
    output_img = np.zeros_like(img)
    
    for h in range(height):
        for w in range(width):
            output_img[h, w] = img[h, w] + amplitude * np.random.normal()
    
    return output_img

def salt_and_pepper(img, thres):
    height, width = img.shape
    output_img = np.zeros_like(img)
    
    for h in range(height):
        for w in range(width):
            random_num = np.random.uniform()
            if random_num < thres:
                output_img[h, w] = 0
            elif random_num > 1 - thres:
                output_img[h, w] = 255
            else:
                output_img[h, w] = img[h, w]

    return output_img

def box_filter(img, filter_size):
    F = np.ones((filter_size, filter_size))

    half_fs = filter_size // 2
    padding_img = cv2.copyMakeBorder(img, half_fs, half_fs, half_fs, half_fs, cv2.BORDER_REFLECT)

    height, width = padding_img.shape
    output_img = np.zeros_like(img)
    
    for h in range(half_fs, height - half_fs):
        for w in range(half_fs, width - half_fs):
            patch = padding_img[h - half_fs:h + half_fs + 1, w - half_fs:w + half_fs + 1]
            output_img[h - half_fs, w - half_fs] = np.sum(patch * F) / (filter_size**2)
    
    return output_img

def median_filter(img, filter_size):
    F = np.ones((filter_size, filter_size))

    half_fs = filter_size // 2
    padding_img = cv2.copyMakeBorder(img, half_fs, half_fs, half_fs, half_fs, cv2.BORDER_REFLECT)

    height, width = padding_img.shape
    output_img = np.zeros_like(img)
    
    for h in range(half_fs, height - half_fs):
        for w in range(half_fs, width - half_fs):
            patch = padding_img[h - half_fs:h + half_fs + 1, w - half_fs:w + half_fs + 1]
            output_img[h - half_fs, w - half_fs] = np.median(patch)
    
    return output_img

def dilation(img, kernel):
    half_ks = kernel.shape[0] // 2
    padding_img = cv2.copyMakeBorder(img, half_ks, half_ks, half_ks, half_ks, cv2.BORDER_REFLECT)

    height, width = padding_img.shape
    output_img = np.zeros_like(img)

    for h in range(half_ks, height - half_ks):
        for w in range(half_ks, width - half_ks):
            patch = padding_img[h - half_ks:h + half_ks + 1, w - half_ks:w + half_ks + 1]
            output_img[h - half_ks, w - half_ks] = np.max(patch[kernel == 1])

    return output_img

def erosion(img, kernel):
    half_ks = kernel.shape[0] // 2
    padding_img = cv2.copyMakeBorder(img, half_ks, half_ks, half_ks, half_ks, cv2.BORDER_REFLECT)

    height, width = padding_img.shape
    output_img = np.zeros_like(img)
    
    for h in range(half_ks, height - half_ks):
        for w in range(half_ks, width - half_ks):
            patch = padding_img[h - half_ks:h + half_ks + 1, w - half_ks:w + half_ks + 1]
            output_img[h - half_ks, w - half_ks] = np.min(patch[kernel == 1])

    return output_img

def opening(img, kernel):
    return dilation(erosion(img, kernel), kernel)

def closing(img, kernel):
    return erosion(dilation(img, kernel), kernel)

def SNR(img, noise_img):
    VS = np.var(img / 255)
    VN = np.var((noise_img / 255 - img / 255) )

    return 20 * np.log10(np.sqrt(VS) / np.sqrt(VN))

def main():
    img_path = 'lena.bmp'
    img = cv2.imread(img_path, 0)

    octogonal_kernel = np.array([
        [0, 1, 1, 1, 0],
        [1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1],
        [0, 1, 1, 1, 0]], dtype=np.uint8)

    noise_img_dict = {
        # (a) Generate noisy images with gaussian noise(amplitude of 10 and 30)
        'GN_10': gaussian_noise(img, 10),
        'GN_30': gaussian_noise(img, 30),

        # (b) Generate noisy images with salt-and-pepper noise( probability 0.1 and 0.05)
        'SAP_01': salt_and_pepper(img, 0.1),
        'SAP_005': salt_and_pepper(img, 0.05),
        }

    for img_name, noise_img in noise_img_dict.items():
        cv2.imwrite(f'{img_name}.png', noise_img)
        snr = SNR(img, noise_img)
        print(f'{img_name} SNR: {snr}')

        for filter_size in [3, 5]:
            # (c) Use the 3x3, 5x5 box filter on images generated by (a)(b)
            denoise_img = box_filter(noise_img, filter_size)
            snr = SNR(img, denoise_img)
            cv2.imwrite(f'BF{filter_size}_{img_name}.png', denoise_img)
            print(f'BF{filter_size}_{img_name} SNR: {snr}')

            # (d) Use 3x3, 5x5 median filter on images generated by (a)(b)
            denoise_img = median_filter(noise_img, filter_size)
            snr = SNR(img, denoise_img)
            cv2.imwrite(f'MF{filter_size}_{img_name}.png', denoise_img)
            print(f'MF{filter_size}_{img_name} SNR: {snr}')

        # (e) Use both opening-then-closing and closing-then opening filter (using the octogonal 3-5-5-5-3 kernel, noise_img = 0) on images generated by (a)(b)
        denoise_img = closing(opening(noise_img, octogonal_kernel), octogonal_kernel)
        snr = SNR(img, denoise_img)
        cv2.imwrite(f'OC_{img_name}.png', denoise_img)
        print(f'OC_{img_name} SNR: {snr}')

        denoise_img = opening(closing(noise_img, octogonal_kernel), octogonal_kernel)
        snr = SNR(img, denoise_img)
        cv2.imwrite(f'CO_{img_name}.png', denoise_img)
        print(f'CO_{img_name} SNR: {snr}')
    
if __name__ == '__main__':
    main()